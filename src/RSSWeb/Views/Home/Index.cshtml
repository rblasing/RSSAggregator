<!-- Copyright 2020 Richard Blasingame. All rights reserved. -->

@{
   Layout = "~/Views/Shared/_Layout.cshtml";
   ViewBag.Title = "News";
}

<table style="margin: 1%">
   <tr>
      <td style="width: 1%">
         <input type="button" value="&#9650;" onclick="fontInc();" class="circle" style="padding: 0 0 1px 0" />
      </td>
      <td style="width: 1%">
         <input type="button" value="&#9660;" onclick="fontDec();" class="circle" style="padding: 1px 0 0 0" />
      </td>
      <td><div id="rsskeywords" onblur="updateKeywords();" contenteditable="true" placeholder="Search terms..." spellcheck="false"></div></td>
   </tr>
</table>

<div id="errors"></div>
<div id="ssecontent">@Html.Raw(ViewBag.topItems)</div>

<template id="tItem">
   <div class="newitem">
      <div class='box'>
         <span class='feedname'></span>
         <span class='itemdate'>
            <label title=''></label>
         </span>
      </div>
      <a target='_blank' class='itemurl' href=''></a>
      <span class='itemdesc'></span>
   </div>
</template>

<script language="javascript" type="text/javascript">
   let fontPct = 100;
   let sseContent;
   let es;

   // display errors in the page, to simplify debugging mobile browsers
   // ONLY USE IN DEV ENVS
   /*window.onerror = function (msg, url, line, col, error)
   {
      let extra = !col ? '' : '<br/>column: ' + col;
      extra += !error ? '' : '<br/>error: ' + error;

      let err = `Error: ${msg}<br/>url: ${url}<br/>line: ${line}${extra}"<hr/>`;
      document.getElementById("errors").innerHTML += err;

      const suppressErrorAlert = true;

      return suppressErrorAlert;
   };*/

   function isNullOrWhitespace(s)
   {
      return !s  ||  !s.trim();
   }

   function isLeapYear(y)
   {
      return ((y % 4 == 0)  &&  ( y % 100 != 0))  ||  (y % 400 == 0);
   }

   function timeSpan(d)
   {
      let span = {};
      let now = new Date();
      span._milliseconds = now.getTime() - d.getTime();
      span.milliseconds = span._milliseconds % 1000;
      span._seconds = (span._milliseconds - span.milliseconds) / 1000;
      span.seconds = span._seconds % 60;
      span._minutes = (span._seconds - span.seconds) / 60;
      span.minutes = span._minutes % 60;
      span._hours = (span._minutes - span.minutes) / 60;
      span.hours = span._hours % 24;
      span._days = (span._hours - span.hours) / 24;
      span.days = span._days % (isLeapYear(now.year) ? 366 : 365);
      span.years = (span._days - span.days) / (isLeapYear(now.year) ? 366 : 365);

      return span;
   }

   function isOnLanWan()
   {
      let conn = navigator.connection  ||  navigator.mozConnection  ||  navigator.webkitConnection;

      if (conn)
      {
         if (conn.type === 'ethernet'  ||  conn.type === "wifi"  ||  conn.type === "wimax")
            return true;
      }

      // on cell data, or can't determine
      return false;
   }

   // show/hide item description when tapped/clicked
   function toggleDesc(e)
   {
      let d = this.getElementsByClassName("itemdesc");
      let currentDisplay = d[0].style.display;

      if (isNullOrWhitespace(d[0].style.display))
         currentDisplay = document.defaultView.getComputedStyle(d[0], null)["display"];

      if (currentDisplay === "none")
         d[0].style.display = "block";
      else
         d[0].style.display = "none";
   }

   // allow user to select font size, and record that preference in local storage
   function fontInc()
   {
      fontPct += 10;
      localStorage.setItem("rssFontPct", fontPct);
      sseContent.style.fontSize = fontPct + "%";
   }

   function fontDec()
   {
      fontPct -= 10;

      if (fontPct == 0)
         fontPct = 10;

      localStorage.setItem("rssFontPct", fontPct);
      sseContent.style.fontSize = fontPct + "%";
   }

   // save user's highlight keywords in local storage, and apply to content
   function updateKeywords()
   {
      let keywords = document.getElementById("rsskeywords").innerText;
      localStorage.setItem("rsskeywords", keywords);

      if (isNullOrWhitespace(keywords))
         return;

      for (let kIdx = 0; kIdx < sseContent.childNodes.length; kIdx++)
         highlight(sseContent.childNodes[kIdx]);
   }

   function highlight(item)
   {
      if (item.className != "newitem")
         item.className = "olditem";

      let keywords = document.getElementById("rsskeywords").innerText;

      if (isNullOrWhitespace(keywords))
         return;

      // split keywords on whitespace
      var searchTerms = keywords.match(/\S+/g)  ||  [];

      for (let hIdx = 0; hIdx < searchTerms.length; hIdx++)
      {
         if (isNullOrWhitespace(searchTerms[hIdx]))
            continue;

         let title = item.getElementsByClassName("itemurl")[0];
         let desc = item.getElementsByClassName("itemdesc")[0];

         if (title.innerHTML.toLowerCase().indexOf(searchTerms[hIdx].toLowerCase()) >= 0  ||
            desc.innerHTML.toLowerCase().indexOf(searchTerms[hIdx].toLowerCase()) >= 0)
         {
            item.className = "impitem";
         }
      }
   }

   // change date elements' labels from UTC to browser's local timezone
   function updateStamps()
   {
      for (let uIdx = 0; uIdx < sseContent.childNodes.length; uIdx++)
         updateStamp(sseContent.childNodes[uIdx]);
   }

   function updateStamp(item)
   {
      item.onclick = toggleDesc;
      var dateNodes = item.getElementsByClassName('itemdate');

      for (let dIdx = 0; dIdx < dateNodes.length; dIdx++)
      {
         let node = dateNodes[dIdx];
         let labels = node.getElementsByTagName('label');

         if (labels.length < 1)
            continue;

         let stamp = new Date(labels[0].innerText);
         stamp = new Date(labels[0].title);
         labels[0].title = stamp;
         let span = timeSpan(stamp);

         if (span.days < 1)
         {
            if (span.hours == 1)
               labels[0].innerText = "1 hour ago";
            else if (span.hours > 1)
               labels[0].innerText = span.hours + " hours ago";
            else if (span.minutes == 0)
               labels[0].innerText = "now";
            else if (span.minutes == 1)
               labels[0].innerText = "1 minute ago";
            else
               labels[0].innerText = span.minutes + " minutes ago";
         }
      }
   }

   // infinite scroll
   if (document.body.touchmove != undefined) // check if the client has a touchscreen
      document.body.touchmove = onScroll;

   window.onscroll = onScroll;

   function onScroll()
   {
      // bottom of viewport
      if ((window.innerHeight + window.scrollY) >= document.body.offsetHeight)
      {
         let urls = sseContent.getElementsByClassName("itemurl");
         let lastUrl = urls[urls.length - 1].href;

         let dates = sseContent.getElementsByClassName("itemdate");
         let lastDate = dates[dates.length - 1].getElementsByTagName('label')[0].title;

         // get next 10 items older than the last one in the current visible content
         getOlderItemsFromDB(lastUrl, lastDate, 10).then(function (items)
         {
            for (let oIdx = 0; oIdx < items.length; oIdx++)
               addItemToContent(items[oIdx], "olditem", true);
         });
      }
   }

   function addItemToContent(item, className, bAppend)
   {
      // make use of the template element defined above, if the browser
      // supports it
      if (document.createElement("template").content)
      {
         let template = document.querySelector('#tItem');
         let clone = template.content.cloneNode(true);
         let div = clone.querySelector(".newitem");
         div.className = className;
         clone.querySelector(".feedname").textContent = item.feedName;
         clone.querySelector(".itemdesc").innerHTML = item.description;

         let e = clone.querySelector(".itemdate label");
         e.title = item.pubDate;
         e.textContent = item.pubDate;

         e = clone.querySelector(".itemurl");
         e.href = item.url;
         e.innerHTML = item.title;

         updateStamp(div);

         if (bAppend)
         {
            highlight(div);
            sseContent.appendChild(div);
         }
         else
            sseContent.insertBefore(div, sseContent.childNodes[0]);
      }
      else
      {
         let newItemTemplate = `<div class='box'><span class='feedname'>" +
            "${item.feedName}</span><span class='itemdate'><label title=" +
            "'${item.pubDate}'>${item.pubDate}</label></span></div><a " +
            "target='_blank' class='itemurl' href='${item.url}'>${item.title}</a>" +
            "<span class='itemdesc'>${item.description}</span>`;

         let newNode = document.createElement("div");
         newNode.innerHTML = newItemTemplate;
         newNode.className = className;
         updateStamp(newNode);

         if (bAppend)
         {
            highlight(newNode);
            sseContent.appendChild(newNode);
         }
         else
            sseContent.insertBefore(newNode, sseContent.childNodes[0]);
      }
   }
   
   function esOnMessage(e)
   {
      try
      {
         // server will occasionally send comments to prevent conn timeout
         if (e.data == "nodata")
         {
            updateStamps();
            return;
         }

         console.log("event id: " + e.lastEventId);
         console.log("new message: " + e.data);

         updateKeywords();

         // set all existing items to old class, unless they contain keywords
         // which are important to the user
         for (let rsIdx = 0; rsIdx < sseContent.childNodes.length; rsIdx++)
         {
            if (sseContent.childNodes[rsIdx].className != "impitem")
               sseContent.childNodes[rsIdx].className = "olditem";
         }

         let newItems = JSON.parse(e.data);

         // insert new items to top of content
         for (let newIdx = 0; newIdx < newItems.length; newIdx++)
         {
            addItemToContent(newItems[newIdx], "newitem", false);
            addItemToDB(newItems[newIdx]);
            updateStamps();
         }

         // cap content view to maxItems
         if (sseContent.childNodes.length > @ViewBag.maxItems)
         {
            for (let capIdx = sseContent.childNodes.length - 1; capIdx >= @ViewBag.maxItems; capIdx--)
               sseContent.removeChild(sseContent.childNodes[capIdx]);
         }
      }
      catch (e)
      {
         console.error("Failed to parse server event: " + e.data);
         console.error(e);
      }
   }
   

   // wire everything up
   window.onload = function ()
   {
      sseContent = document.getElementById("ssecontent");

      // create local DB, if it doesn't already exist
      createDB();

      // apply user preferences
      let initPct = localStorage.getItem("rssFontPct");

      if (initPct != null)
      {
         fontPct = parseInt(initPct);
         sseContent.style.fontSize = initPct + "%";
      }

      let initKeywords = localStorage.getItem("rsskeywords");

      if (initKeywords != null)
      {
         document.getElementById("rsskeywords").innerText = initKeywords;
         updateKeywords();
      }

      updateStamps();

      // start listening for SSE messages (if supported by browser)
      if (window.EventSource == undefined)
         return;

      getMaxItemStamp().then(function (stamp)
      {
         // try to catchup on missed items, but only if on a LAN or WAN. Don't
         // waste cell data on this
         if (isOnLanWan()  &&  stamp != null)
            es = new EventSource("@ViewBag.sseUri" + "?Last-Event-Id=" + stamp);
         else
            es = new EventSource("@ViewBag.sseUri");

         es.addEventListener("helo", function (e)
         {
            console.log("SSE: HELO message received");
         }, false);

         es.addEventListener("log", function (e)
         {
            try
            {
               sseContent.innerHTML = e.data;
            }
            catch (e)
            {
               console.error("Failed to parse server event: " + e.data);
               console.error(e);
            }
         }, false);

         // new SSE message received from server
         es.addEventListener("message", esOnMessage, false);

         es.addEventListener("open", function (e)
         {
            console.log("SSE: connection opened");
         }, false);

         es.addEventListener("error", function (e)
         {
            if (e.target.readyState == EventSource.CLOSED)
               console.log("SSE: connection closed");
            else if (e.target.readyState == EventSource.CONNECTING)
               console.log("SSE: reconnecting");
            else
               console.error(e);
         }, false);
      });
   };
</script>